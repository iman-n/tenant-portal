name: Deploy to AWS with Terraform

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    # Checkout the repository
    - name: Checkout code
      uses: actions/checkout@v3

    # Set up Terraform CLI
    - name: Set up Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
        terraform_version: latest

    # Configure AWS credentials
    - name: Configure AWS
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    # Initialize Terraform
    - name: Terraform Init
      run: terraform init

    # Apply Terraform
    - name: Terraform Apply
      id: tf_apply
      run: |
        terraform apply -auto-approve
        # Extract public IP from output
        terraform output -raw instance_ip > instance_ip.txt

    # Set public IP as environment variable
    - name: Extract Public IP
      run: |
        export PUBLIC_IP=$(cat instance_ip.txt)
        echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV

    # Log in to Amazon ECR
    - name: Log in to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    # Build and push backend Docker image
    - name: Build and Push Backend Image
      run: |
        docker build -t backend .
        docker tag backend:latest ${{ secrets.ECR_REPOSITORY }}/backend:latest
        docker push ${{ secrets.ECR_REPOSITORY }}/backend:latest

    # Build and push frontend Docker image with dynamic public IP
    - name: Build and Push Frontend Image
      run: |
        docker build --build-arg VITE_GRAPHQL_URI=http://${{ env.PUBLIC_IP }}:3000/graphql -t frontend ./frontend
        docker tag frontend:latest ${{ secrets.ECR_REPOSITORY }}/frontend:latest
        docker push ${{ secrets.ECR_REPOSITORY }}/frontend:latest

    # Deploy on EC2
    - name: SSH and Deploy
      run: |
        # Copy docker-compose.prod.yml and .env to EC2
        scp -o StrictHostKeyChecking=no -i ${{ secrets.EC2_KEY_PATH }} docker-compose.prod.yml ubuntu@${{ env.PUBLIC_IP }}:/home/ubuntu/

        aws ecr get-login-password --region eu-central-1 | docker login --username AWS --password-stdin 552912569893.dkr.ecr.eu-central-1.amazonaws.com

        # Retrieve environment variables from SSM
        export OPENAI_API_KEY=$(aws ssm get-parameter --name "/tenant-test/OPENAI_API_KEY" --with-decryption --query "Parameter.Value" --output text)
        export DATABASE_URL=$(aws ssm get-parameter --name "/tenant-test/DATABASE_URL" --query "Parameter.Value" --output text)
        export REDIS_URL=$(aws ssm get-parameter --name "/tenant-test/REDIS_URL" --query "Parameter.Value" --output text)
        export POSTGRES_USER=$(aws ssm get-parameter --name "/tenant-test/POSTGRES_USER" --with-decryption --query "Parameter.Value" --output text)
        export POSTGRES_PASSWORD=$(aws ssm get-parameter --name "/tenant-test/POSTGRES_PASSWORD" --with-decryption --query "Parameter.Value" --output text)
        export POSTGRES_DB=$(aws ssm get-parameter --name "/tenant-test/POSTGRES_DB" --with-decryption --query "Parameter.Value" --output text)

        ssh -o StrictHostKeyChecking=no -i ${{ secrets.EC2_KEY_PATH }} ubuntu@${{ env.PUBLIC_IP }} << EOF
        cd /path/to/docker-compose/files
        docker-compose -f docker-compose.prod.yml pull
        docker-compose -f docker-compose.prod.yml up -d --remove-orphans
        EOF
